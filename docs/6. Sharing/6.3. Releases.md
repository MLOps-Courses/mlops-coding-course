---
description: Learn how to create and manage stable project releases for your MLOps projects, including versioning strategies, Git workflows, and best practices for communicating changes.
---

# 6.3. Releases

## What is a project release?

[A project release](https://docs.github.com/en/repositories/releasing-projects-on-github/about-releases) is a formal, versioned package of your project's code and its related artifacts, such as compiled binaries, container images, and documentation. It marks a stable, specific point in the project's history, documenting a curated list of new features, bug fixes, and performance improvements. Each release serves as a reliable checkpoint that other developers and users can depend on.

## Why are project releases essential?

- **Communicate Progress**: Releases provide a clear, structured way to inform users about new features, bug fixes, and other improvements, managing expectations and demonstrating the project's evolution.
- **Establish Milestones**: They divide the development process into manageable [milestones](https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/about-milestones), helping teams track progress against a timeline and adjust goals as needed.
- **Guarantee Stability**: Each release is a quality gate, ensuring the software meets defined standards for stability and consistency. This builds trust and provides a reliable user experience.

Ultimately, a release is a contract between you and your users. Referencing a specific version, like `v1.2.3`, guarantees a consistent set of features and behaviors, which is critical for building and maintaining trust as your project grows.

## How often should you create releases?

The ideal release frequency depends on your project's nature and goals. Rapidly evolving projects may benefit from short cycles (e.g., every few weeks), while others might adopt longer intervals (e.g., quarterly). The key is to establish a predictable schedule that balances the need for new features with the assurance of stability. A clear versioning scheme is crucial to avoid compatibility issues.

## Which Git workflow is right for your project?

Choosing the right Git workflow is critical for effective collaboration and efficient project management. Here are three popular options:

### [GitHub Flow](https://docs.github.com/en/get-started/using-github/github-flow)

A simple and streamlined workflow, ideal for projects that practice continuous delivery.

- **Core Principle**: The `main` branch is always stable and deployable.
- **Process**: New work is done on descriptive feature branches, which are then merged into `main` via a Pull Request (PR) after review.
- **Best For**: Small to medium-sized teams and web applications that require frequent releases.

### [Git Flow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow)

A more structured and robust workflow designed for projects with scheduled release cycles.

- **Core Principle**: Uses two long-lived branches: `main` for stable release history and `develop` for integrating new features.
- **Process**: Feature branches are created from `develop`. When a release is planned, a `release` branch is created from `develop`, stabilized, and then merged into both `main` and `develop`. `hotfix` branches are used for urgent production fixes.
- **Best For**: Large, complex projects with multiple versions in production and a formal release schedule.

### [Forking Workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/forking-workflow)

A distributed workflow that is the standard for public open-source projects.

- **Core Principle**: Every contributor works on their own server-side copy (a fork) of the repository.
- **Process**: Contributors push changes to their personal fork and submit a PR to the main repository. A central maintainer reviews and merges the PR.
- **Best For**: Open-source projects or any project with a large, distributed team of contributors who may not have direct push access.

### Comparison

| Workflow | Best For | Key Advantage | Potential Drawback |
| :--- | :--- | :--- | :--- |
| **GitHub Flow** | Continuous delivery, small teams | Simplicity and speed | Less suitable for managing multiple versions |
| **Git Flow** | Scheduled releases, large projects | Structure and parallel development | Can be overly complex for simple projects |
| **Forking Workflow** | Open-source, distributed teams | Clean project history, clear contribution path | Higher barrier to entry for new contributors |

## Which versioning scheme should you use?

Choosing a consistent versioning scheme is vital for communicating the nature of changes between releases.

- **[SemVer (Semantic Versioning)](https://semver.org/)**: This is the most widely adopted standard. It uses a `MAJOR.MINOR.PATCH` format (e.g., `2.1.4`).
    - **MAJOR**: Incremented for incompatible API changes (breaking changes).
    - **MINOR**: Incremented for new, backward-compatible functionality.
    - **PATCH**: Incremented for backward-compatible bug fixes.
- **[CalVer (Calendar Versioning)](https://calver.org/)**: This scheme uses the release date as part of the version (e.g., `YYYY.MM.MICRO`). It's useful for projects where the release date is the most important piece of information, such as time-sensitive applications or services.

Python projects often follow [PEP 440](https://peps.python.org/pep-0440/), which defines a comprehensive scheme that accommodates pre-releases, post-releases, and developmental versions.

For most libraries and tools, **[SemVer](https://semver.org/) is highly recommended** because it clearly communicates the impact of updates to users.

## How do you create a release on GitHub?

[Creating a release on GitHub](https://docs.github.com/en/repositories/releasing-projects-on-github/managing-releases-in-a-repository) formalizes your Git tag, making it accessible to your users.

1.  Navigate to your repository's main page and click on **Releases** in the right-hand sidebar.
2.  Click **Draft a new release**.
3.  Choose an existing Git tag or create a new one. The tag version should follow your chosen versioning scheme (e.g., `v1.2.3`).
4.  Write a clear release title and a detailed description. You can auto-generate release notes from merged PRs.
5.  (Optional) Attach binary files, such as compiled executables or installers.
6.  Publish the release. It will now appear on your repository's releases page.

## How do you coordinate a release with a team?

Effective team collaboration relies on GitHub's project management tools:

- **[Issues](https://docs.github.com/en/issues/tracking-your-work-with-issues/about-issues)**: Track bugs, feature requests, and other tasks.
- **[Labels](https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/managing-labels)**: Categorize issues by type (`bug`, `feature`), priority (`high`, `low`), or status (`in-progress`).
- **[Milestones](https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/about-milestones)**: Group issues into a single release target. This provides a clear overview of progress and helps ensure all planned work is completed.

Using these tools keeps the team aligned on release goals and timelines.

## How do you review and merge contributions for a release?

A structured review process ensures code quality and consistency.

1.  **Branching**: Contributors create a new branch from the main development line (`main` or `develop`) for each distinct feature or fix.
2.  **[Pull Request (PR)](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests)**: Once work is complete, the contributor opens a PR to merge their changes into the target branch. The PR description should clearly explain the "what" and "why" of the change.
3.  **[Code Review](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/about-pull-request-reviews)**: Other team members review the code, providing feedback and suggesting improvements. Automated checks (like tests and linters) should also run at this stage.
4.  **Merge**: After approval, the PR is merged, integrating the new code into the main development line. The feature branch can then be deleted.

## What are the final steps before creating a release?

Before tagging a release, complete this pre-flight checklist:

- **Testing**: Run the full test suite to confirm that all features work as expected and no regressions have been introduced.
- **Documentation**: Update all relevant documentation, including READMEs, user guides, and API references.
- **[Changelog](https://en.wikipedia.org/wiki/Changelog)**: Finalize the changelog. Tools like `commitizen` can automate this by generating a summary of changes from your commit history.
- **Dependencies**: Review and update project dependencies to address any known vulnerabilities.

## How can you automate the release process?

Automating releases with CI/CD pipelines saves time and reduces human error. Using GitHub Actions, you can create a workflow that triggers on a push to a specific branch or a new tag.

A typical automated release workflow includes these steps:

1. **Version Bumping**: Automatically increment the project version in files like `pyproject.toml` or `package.json`.
2. **Changelog Generation**: Generate a changelog from commit messages following a convention like Conventional Commits.
3. **Tagging and Releasing**: Create a Git tag and a GitHub Release with the generated changelog.
4. **Building Artifacts**: Build binaries, container images, or other distributable assets.
5. **Publishing**: Push packages to registries like PyPI or Docker Hub.

## How should you communicate release changes?

Clear communication is key to user adoption and trust.

- **[GitHub Release Page](https://docs.github.com/en/repositories/releasing-projects-on-github/managing-releases-in-a-repository)**: This is the primary source of truth, with detailed release notes and downloadable assets.
- **[CHANGELOG.md](https://en.wikipedia.org/wiki/Changelog)**: A file in your repository that provides a cumulative, version-by-version history of changes, often following the [Keep a Changelog](https://keepachangelog.com/) format.
- **[GitHub Pages](https://pages.github.com/)**: Host version-specific documentation, allowing users to access the docs relevant to their version of the software.

## How long should you support previous releases?

The support window for past releases depends on your project's resources and user base. Critical projects, like the Python language, offer [Long-Term Support (LTS)](https://en.wikipedia.org/wiki/Long-term_support) for specific versions, providing security patches and critical bug fixes for years.

Establish a clear support policy and communicate it to your users. This helps them plan upgrades and builds confidence in your project's reliability.

## Additional Resources

- **[Release page from the MLOps Python Package](https://github.com/fmind/mlops-python-package/releases)**
- [Managing releases in a GitHub repository](https://docs.github.com/en/repositories/releasing-projects-on-github/managing-releases-in-a-repository)
