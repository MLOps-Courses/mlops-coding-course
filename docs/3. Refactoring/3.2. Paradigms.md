# 3.3. Paradigms

## What is a programming paradigm?

[A programming paradigm](https://en.wikipedia.org/wiki/Programming_paradigm) refers to a style or methodology of programming that provides a framework for structuring and solving problems. Paradigms influence how we organize, write, and think about code. Common programming paradigms include [procedural](https://en.wikipedia.org/wiki/Procedural_programming), [object-oriented](https://en.wikipedia.org/wiki/Object-oriented_programming), [functional](https://en.wikipedia.org/wiki/Functional_programming), and [declarative](https://en.wikipedia.org/wiki/Declarative_programming) programming. Each paradigm offers a unique approach to code organization, abstraction, and reuse.

- **[Procedural programming](https://en.wikipedia.org/wiki/Procedural_programming)** emphasizes a step-by-step set of instructions, focusing on routines or subroutines to process data.
- **[Object-oriented programming (OOP)](https://en.wikipedia.org/wiki/Object-oriented_programming)** encapsulates data and functions that operate on that data within objects, promoting modularity and reuse.
- **[Functional programming](https://en.wikipedia.org/wiki/Functional_programming)** treats computation as the evaluation of mathematical functions, avoiding changing state and mutable data.
- **[Declarative programming](https://en.wikipedia.org/wiki/Declarative_programming)** specifies what the program should accomplish rather than explicitly listing commands or steps to achieve it.

In the provided Python example, using type hints and a docstring within a function showcases best practices in procedural programming:

```python
def load_dataset(path: str) -> pd.DataFrame:
    """Load a CSV dataset from a local path."""
    return pd.read_csv(path)
```

For an example of an object-oriented approach, consider a class in Python designed for machine learning tasks, which encapsulates model training and prediction logic:

```python
from sklearn.ensemble import RandomForestClassifier
from sklearn.base import BaseEstimator, TransformerMixin

class CustomModel(BaseEstimator, TransformerMixin):
    def __init__(self, params: dict[str, object]):
        self.model = RandomForestClassifier(**params)

    def fit(self, X: pd.DataFrame, y: pd.Series = None) -> "CustomModel":
        return self.model.fit(X, y)

    def predict(self, X: pd.DataFrame) -> pd.Series:
        # Prediction logic here
        return self.model.predict(X)
```

This class demonstrates how to structure a machine learning model in an object-oriented way, making it compatible with `scikit-learn`'s pipeline and model selection tools.

## Why do you need to use functions and objects?

Functions and objects play a crucial role in structuring code in a readable, maintainable, and reusable manner. They allow you to encapsulate functionality and state, making complex software systems more manageable.

Functions enable you to define a block of code that performs a single action, which can be executed whenever the function is called. This promotes code reuse and simplifies debugging and testing by isolating functionality.

Objects, fundamental to the object-oriented programming paradigm, bundle data and the methods that operate on that data. This encapsulation fosters modularity, as objects can be developed independently and used in different contexts.

## How should you write a new function or object?

When identifying opportunities to encapsulate code into functions or objects, look for repetitive code patterns, complex logic that needs isolation, or concepts that can be modeled as real-world objects.

In the case of repetitive data loading tasks, abstracting the logic into a function simplifies the process:

```python
def load_dataset(path: str, index_col: str = "Id") -> pd.DataFrame:
    """Load a CSV dataset from a local path."""
    dataset = pd.read_csv(path, index_col=index_col)
    print(dataset.shape)
    return dataset
```

When it comes to objects, encapsulate data and behavior that logically belong together. For instance, a `DataPreprocessor` class could encapsulate methods for cleaning, normalizing, and transforming data, keeping these operations neatly packaged and reusable.

## How should you organize all your functions and objects?

Structuring functions and objects into modules helps maintain a clean and navigable codebase. This structure should evolve naturally, starting from a simple layout and growing in complexity as the project expands. For example:

- `data.py` for data loading, processing functions, and classes.
- `utils.py` for utility functions and classes that support various parts of the project.
- `models.py` for classes representing machine learning models and their logic.

This modular approach aids in separation of concerns, making your code more organized and manageable.

## What are the best practices for creating functions and objects?

Following best practices ensures that your functions and objects are reliable, maintainable, and easy to understand:

1. **[Type Hints](https://docs.python.org/3/library/typing.html)**: Specify input and output types to improve code readability and tooling support.
2. **[Docstrings](https://peps.python.org/pep-0257/)**: Describe the purpose and usage of functions and objects, including parameters and return values.
3. **[Single Responsibility](https://en.wikipedia.org/wiki/Single-responsibility_principle)**: Aim for each function and object to perform a single task or represent a single concept.
4. **Descriptive Names**: Choose names that clearly convey the purpose and functionality.
5. **Default Arguments**: Use default arguments to provide flexibility, with caution around mutable defaults.
6. **Error Handling**: Incorporate error handling and validations to make your code robust.
7. **Limit Parameters**: Keep the number of parameters to a minimum for simplicity and ease of use.
8. **Avoid Global Variables**: Use local variables within functions and objects to avoid unintended side effects.
9. **Testing**: Regularly test your code to catch and fix errors early.
10. **Readability**: Prioritize clear and straightforward code, making it accessible to others (and your future self).

## Paradigm additional resources

- **[Paradigm examples from the MLOps Python Package](https://github.com/fmind/mlops-python-package/tree/main/src/bikes)**
- [Finding Harmony in MLOps: Balancing Functional and Object-Oriented Approaches â˜¯](https://fmind.medium.com/finding-harmony-in-mlops-balancing-functional-and-object-oriented-approaches-503591be6d9b)
- [Programming Paradigms](https://en.wikipedia.org/wiki/Programming_paradigm)