---
description: Learn best practices for organizing Python imports in notebooks to ensure clarity, maintainability, and efficient code management.
---

# üì• 2.1 Imports

In Python, **[code imports](https://docs.python.org/3/reference/import.html)** are statements that allow you to use code from other modules. This is fundamental to reusing code and keeping your projects organized.

## üì¶ What are code imports?

In Python, an `import` statement serves to bring functionality from other code files, known as modules, into your current script or notebook. This mechanism is essential for building on top of existing libraries and frameworks, allowing you to leverage the vast Python ecosystem.

As per the official **[PEP 8](https://peps.python.org/pep-0008/#imports)** style guide, imports should be grouped in the following order at the top of a file:

1.  **Standard library imports:** Modules that are part of the Python standard library (e.g., `os`, `sys`, `datetime`).
2.  **Third-party imports:** Packages that you have installed, such as `pandas`, `numpy`, or `scikit-learn`.
3.  **Local application/library specific imports:** Modules that are part of your own project.

Here is an example of how to structure your imports:

```python
# Standard library imports
import os
import sys

# Third-party imports
import numpy as np
import pandas as pd
from sklearn.ensemble import RandomForestClassifier

# Local application/library specific imports
from my_project import my_module
```

## ü§î Which packages do you need for your project?

For most data science projects, a common set of libraries will provide the foundation for your work. These include:

-   **[Pandas](https://pandas.pydata.org/):** For data manipulation and analysis.
-   **[NumPy](https://numpy.org/):** For numerical operations, especially with arrays.
-   **[Matplotlib](https://matplotlib.org/)** or **[Plotly](https://plotly.com/python/):** For data visualization.
-   **[Scikit-learn](https://scikit-learn.org/stable/):** For machine learning algorithms and tools.

You can add these to your project with `uv`:

```bash
uv add pandas numpy matplotlib scikit-learn plotly
```

This command will install the packages and their dependencies into your project's virtual environment.

## üóÇÔ∏è How should you organize your imports to facilitate your work?

A clean import section makes your code more readable and maintainable. It's a common convention to import entire modules, often with a standard alias, rather than importing specific functions or classes. This makes it clear where each function or class comes from.

For example, instead of this:

```python
# Less clear, as the origin of RandomForestClassifier is not immediately obvious
from sklearn.ensemble import RandomForestClassifier

model = RandomForestClassifier()
```

Prefer this:

```python
# Clearer, as ensemble.RandomForestClassifier shows the module
from sklearn import ensemble

model = ensemble.RandomForestClassifier()
```

Even better, for commonly used libraries like `pandas` or `numpy`, use their standard aliases:

```python
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.rand(5, 5))
```

## üí• What are the risks if you import classes and functions with the same name?

Importing classes or functions with the same name from different modules can lead to **name collisions**. The last import will overwrite the previous one, which can cause subtle bugs that are hard to track down.

For example:

```python
from module1 import load
from module2 import load  # This overwrites the 'load' from module1

# This will call the 'load' function from module2
load()
```

To avoid this, you can use aliases for your imports:

```python
from module1 import load as load_from_module1
from module2 import load as load_from_module2

load_from_module1()
load_from_module2()
```

This makes it explicit which function you are calling.

## ‚ö°Ô∏è Are there any side effects when importing modules in Python?

Yes, importing a module executes all the top-level code within that module. This is a powerful feature, but it can have unintended side effects. For example, if a module contains code that modifies your environment or executes a system command, this will happen at the time of import.

```python
# lib.py
import os

print("This will be printed on import")
os.system("echo 'Creating a file...' > new_file.txt") # This will run on import
```

```python
# main.py
import lib  # This will print the message and create the file
```

Because of this, it's a best practice to only import from trusted sources.

## ‚ü≥ What about reloading modules in a notebook?

When you are actively developing a local module and using it in a Jupyter notebook, you might find that changes you make to the module's source code are not reflected when you re-run a cell. This is because Python's import system caches modules after the first import.

To force a reload of your modules, you can use the `%autoreload` magic command:

```python
%load_ext autoreload
%autoreload 2
```

Place this at the top of your notebook. It will automatically reload modules before executing your code, so you always have the latest version.

## ‚ùì What should you do if packages cannot be imported from your notebook?

If you get an `ImportError`, it usually means that the package is not installed in the Python environment that your notebook is using. To debug this, you can check the Python interpreter and the paths it searches for modules:

```python
import sys

print("Interpreter path:", sys.executable)
print("Module search paths:", sys.path)
```

Ensure that the interpreter path points to the virtual environment where you installed your packages. In VS Code, you can easily switch between Python environments to select the correct one for your project (e.g., `.venv`).

## üîë Key Takeaways

-   **Order your imports:** Follow the PEP 8 convention: standard library, third-party, then local application imports.
-   **Use clear import statements:** Prefer importing modules (`from sklearn import ensemble`) over specific, deeply nested functions to maintain clarity.
-   **Avoid name collisions:** Use aliases (`import numpy as np`) when importing modules with common names or to avoid overwriting functions.
-   **Be aware of side effects:** Importing a module runs its top-level code, so only import from trusted sources.
-   **Use `%autoreload` in notebooks:** This magic command saves you from having to restart the kernel to see changes in your local modules.
-   **Check your environment:** If you have import errors, verify that you are using the correct Python interpreter for your project.

## üìö Additional resources

-   **[Imports example from the MLOps Python Package](https://github.com/fmind/mlops-python-package/blob/main/notebooks/prototype.ipynb)**
-   [Python import: Advanced Techniques and Tips](https://realpython.com/python-import/)
-   [The Python import system](https://docs.python.org/3/reference/import.html)
