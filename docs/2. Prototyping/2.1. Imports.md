# üìù 2.1. Managing Imports

Properly managing imports is a cornerstone of a well-structured and maintainable AI/ML project. It ensures that your code is clean, readable, and scalable. In the prototyping phase, especially within notebooks, it's easy to create a tangled web of dependencies. This section will guide you through the best practices for handling imports, moving from common pitfalls to professional standards.

## The "Quick and Dirty" Method: `sys.path`

When you start working on a project with multiple notebooks or scripts, you'll inevitably need to share code between them. A common first attempt is to manipulate Python's `sys.path`.

For example, if you have a utility function in `src/utils.py` and you want to use it in `notebooks/prototype.ipynb`, you might be tempted to do this:

```python
import sys

# Add the project root to the Python path
sys.path.append("..")

from src import utils
```

**Why you should avoid this:**

*   **It's brittle:** This approach depends on the file structure. If you move the notebook, the relative path `..` might break.
*   **IDE Confusion:** Your Integrated Development Environment (IDE) like VS Code might not recognize these "on-the-fly" path changes, leading to incorrect error highlighting and no autocompletion for your modules.
*   **It's not portable:** When someone else clones your project, they might have a different structure, or they might not realize they need to run the notebook from a specific directory.

While `sys.path` manipulation can be a quick fix, it leads to code that is hard to maintain and understand in the long run.

## The Professional Approach: Editable Installs

A much cleaner and more robust solution is to treat your project as a Python package. By installing your project in "editable" mode, you make your project's modules available everywhere in your environment, just like any other library (e.g., `pandas`, `scikit-learn`).

You can do this with a single command at the root of your project:

```bash
# Using uv (recommended for this course)
uv pip install -e .

# Or using standard pip
pip install -e .
```

The `-e` flag stands for "editable," which means that any changes you make to your source code are immediately reflected in the installed package without needing to reinstall it.

**Benefits of this approach:**

*   **Clean Imports:** You can now use absolute imports from anywhere in your project, which is much cleaner and more readable.
    ```python
    # No more sys.path hacks!
    from mlops.dataset import load_data
    ```
*   **IDE Friendly:** Your IDE will now correctly recognize your project's structure, giving you features like autocompletion, go-to-definition, and refactoring support.
*   **Consistency:** It ensures that your prototyping environment (notebooks) and your production environment (scripts) handle imports in the exact same way.
*   **Collaboration:** Anyone who clones your repository can set up their environment with the same single command, ensuring consistency across the team.

This is the standard and recommended way to manage dependencies within a Python project.

## Best Practices for Clean Imports

Once you have your project set up for proper importing, it's important to keep your import statements clean and organized.

### 1. Organize Your Imports (PEP 8)

[PEP 8](https://peps.python.org/pep-0008/#imports), the official style guide for Python code, recommends grouping imports in the following order:

1.  **Standard library imports** (e.g., `sys`, `os`, `json`)
2.  **Third-party library imports** (e.g., `pandas`, `numpy`, `sklearn`)
3.  **Local application/library specific imports** (your own project's modules)

Here‚Äôs an example:

```python
# 1. Standard library
import json
import sys
from pathlib import Path

# 2. Third-party libraries
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split

# 3. Local application
from mlops.dataset import load_data
from mlops.models import train_model
```

This structure makes it easy to see the dependencies of a script at a glance. Tools like `isort` can even automate this for you.

### 2. Use Absolute Imports

With an editable install, you should favor absolute imports over relative imports.

*   **Absolute import:** `from my_package.my_module import my_function`
*   **Relative import:** `from ..my_module import my_function`

Absolute imports are more explicit and prevent ambiguity. You can tell exactly where the module is located within your project structure. Relative imports can be convenient for modules deep within a package, but for top-level scripts and notebooks, absolute imports are much safer and clearer.

## Key Takeaways

*   **Avoid `sys.path` manipulation.** It's a temporary fix that creates long-term problems.
*   **Install your project in editable mode** (`uv pip install -e .`). This is the professional standard.
*   **Organize your imports** into three sections: standard library, third-party, and local application.
*   **Prefer absolute imports** for clarity and maintainability.

By following these guidelines, you'll set a solid foundation for your MLOps project, making your transition from prototyping to production much smoother.
